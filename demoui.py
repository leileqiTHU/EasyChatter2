# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'demoui.ui'
#
# Created by: PyQt5 UI code generator 5.15.2
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import *
from PyQt5.QtWidgets import *
from PyQt5.QtGui import *
import sys
import threading
from PyQt5 import QtCore, QtGui, QtWidgets
from netutils import *
import pyaudio
from uidemo import Ui_MainWindow
CHUNK = 1024
FORMAT = pyaudio.paInt16
CHANNELS = 1
RATE = 44100
class Window_MainWindow(QMainWindow, Ui_MainWindow,NetFunctions):
    def __init__(self, parent=None):
        super(Window_MainWindow, self).__init__(parent)
        self.username='test'
        self.password='123455'
        self.setupUi(self)
        self.friendnameFrame.returnPressed.connect(self.connectFriend)
        self.inputframe.returnPressed.connect(self.fun)
        self.pushButton.clicked.connect(self.cancel)
        self.historytext = ''
        self.outputframe.setTextColor(QtGui.QColor('darkslategrey'))

        self.timer_camera = QTimer(self)
        self.cap = cv2.VideoCapture(0)
        self.timer_camera.timeout.connect(self.show_pic)
        self.timer_camera.start(10)

        self.timer_send_video = QTimer(self)
        self.timer_send_video.timeout.connect(self.send_video)
        self.timer_receive_video = QTimer(self)
        self.timer_receive_video.timeout.connect(self.receive_video)
        self.timer_receive_text = QTimer(self)
        self.timer_receive_text.timeout.connect(self.receive_text)
        self.timer_send_voice = QTimer(self)
        self.timer_send_voice.timeout.connect(self.sendVoice)
        self.timer_send_voice = QTimer(self)
        self.timer_send_voice.timeout.connect(self.sendVoice)
        self.timer_receive_voice = QTimer(self)
        self.timer_receive_voice.timeout.connect(self.recvVoice)
        self.timer_receive_video.start(10)
        self.timer_send_video.start(10)
        self.timer_receive_text.start(10)
        self.timer_send_voice.start(1)
        self.timer_receive_voice.start(1)

        self.listensocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.listenhost = socket.gethostname()
        self.listensocket.setblocking(False)
        self.listensocket.bind(('0.0.0.0', 12000))
        self.listensocket.listen(5)

        self.timer_listenservertcp = QTimer(self)
        self.timer_listenservertcp.timeout.connect(self.listen)
        self.timer_listenservertcp.start(5)
        self.is_connect = False
        with open('./privkey.pem') as f:#这个应该在联网的时候由服务器发过来，然后不在本地存储
            self.privkey = rsa.PrivateKey.load_pkcs1(f.read())

        self.encode_param=[int(cv2.IMWRITE_JPEG_QUALITY),15]
    def sendVoice(self):
        if self.is_connect:
            try:
                stringVoiceData = self.stream.read(CHUNK)
            except Exception as e:
                print(e)
                self.p = pyaudio.PyAudio()
                #定义声音输入流，直接调用stream.read(CHUNK)函数即可获取对应的data
                self.stream = self.p.open(format=FORMAT, channels = CHANNELS, rate = RATE, input = True, frames_per_buffer = CHUNK)
                self.ostream = self.p.open(format=FORMAT, channels = CHANNELS, rate = RATE, output=True, frames_per_buffer = CHUNK)
            try:
                self.sendData(self.sendvoiceudp, stringVoiceData,self.key)
            except:
                pass
        else:
            try:
                self.stream.stop_stream()
                self.stream.close()
                self.p.terminate()
            except:
                pass
        self.timer_send_voice.start(1)
    def recvVoice(self):
        if self.is_connect:
            try:
                stringData = self.recvData(self.receivevoiceudp,self.key)
            except:
                return
            try:
                self.ostream.write(stringData)
            except Exception as e:
                print(e)
                self.p = pyaudio.PyAudio()
                #定义声音输入流，直接调用stream.read(CHUNK)函数即可获取对应的data
                self.stream = self.p.open(format=FORMAT, channels = CHANNELS, rate = RATE, input = True, frames_per_buffer = CHUNK)
                self.ostream = self.p.open(format=FORMAT, channels = CHANNELS, rate = RATE, output=True, frames_per_buffer = CHUNK)
        self.timer_receive_voice.start(1)
        
    def cancel(self):
        self.is_connect=False
    def connectFriend(self):
        #print('connect')
        friendName = self.friendnameFrame.text()
        if(friendName==self.username):
            QMessageBox.critical(self,"错误","不能与自己通信！",QMessageBox.Yes )
            return
        self.verify()
        
        # 索要票据
        data = friendName.encode()
        self.sendData(self.servertcp,data)
        #接收票据及Bip、B的公钥
        res = self.recvData(self.servertcp)
        if(res!='yes'.encode()):
            self.friendipLabel.setText("查无此人")
            return
        print('x1')
        ticket = self.recvData(self.servertcp)
        print('x2')
        self.Bip = self.recvData(self.servertcp).decode()
        print(self.Bip)
        self.Bpubkey = self.recvData(self.servertcp)
        self.Bpubkey = rsa.PublicKey.load_pkcs1(self.Bpubkey)
        # servertcp.close()
        self.friendipLabel.setText(self.Bip)
        #建立与B的连接
        self.Btcp = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        try:
            self.Btcp.settimeout(5)
            self.Btcp.connect((self.Bip,12000))
        except:
            self.friendipLabel.setText("连接中")
            QMessageBox.critical(self,"错误","对方无应答",QMessageBox.Yes )
            self.friendipLabel.setText("0.0.0.0")
            return
        print('send data...')
        #发送票据
        print('发送票据')
        self.sendData(self.Btcp, ticket)
        #接收验证消息
        print('接收验证消息')
        try:
            data = self.recvData(self.Btcp)
        except:
            QMessageBox.critical(self,"错误","连接已断开",QMessageBox.Yes )
            return
        #提取自己的私钥并解密
        # with open('privkey.pem') as f:
        #     privkey = rsa.PrivateKey.load_pkcs1(f.read())
        data = self.decrypt(data, self.privkey)
        #发回验证消息
        print('验证')
        data
        data = str((data,self.username)).encode()
        data = self.encrypt(data, self.Bpubkey)
        self.sendData(self.Btcp, data)
        #接收AES密钥
        print('接收密钥')
        self.Btcp.settimeout(10)
        try:
            data = self.recvData(self.Btcp)
        except:
            QMessageBox.critical(self,"错误","连接超时！",QMessageBox.Yes )
            return
        self.key = self.decrypt(data, self.privkey)

        # self.timer_camera.timeout.connect(self.videochat)
        self.videoudp = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.videoudp.connect((self.Bip,9999))
        self.sendvoiceudp = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.sendvoiceudp.connect((self.Bip,9998))
        self.receiveVideoUdp = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.receiveVideoUdp.bind(('0.0.0.0', 9999))
        self.receiveVideoUdp.setblocking(False)
        self.receivevoiceudp = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.receivevoiceudp.bind(('0.0.0.0', 9998))
        self.receivevoiceudp.setblocking(False)
        self.is_connect = True
        print('完成连接工作')
        # self.receive_text_thread = ReceiveTextThread(self.Btcp,self.inputframe,self.outputframe,self.key,self)
        # self.receive_text_thread.start()
    def send_video(self):#send video
        # print('send_video')
        #cv2.imencode将图片格式转换(编码)成流数据，赋值到内存缓存中;主要用于图像数据格式的压缩，方便网络传输
        #'.jpg'表示将图片按照jpg格式编码。
        if self.is_connect:
            success, frame=self.cap.read()
            if success:
                result, imgencode = cv2.imencode('.jpg', frame, self.encode_param)
                #建立矩阵
                videodata = np.array(imgencode)
                #将numpy矩阵转换成buffer形式，以便在网络中传输
                stringVideoData = videodata.tostring()
                ##传输长度和内容
                self.sendData(self.videoudp, stringVideoData,self.key)
        self.timer_send_video.start(10)

    def receive_video(self):#receive video
        # print('receive video')
        if self.is_connect:
            try:
                # #print(self.Bip)
                # #print(self.receiveVideoUdp.getsockname())
                stringVideoData = self.recvData(self.receiveVideoUdp,self.key,ip=self.Bip)
            except:
                self.timer_receive_video.start(10)
                return
            videodata = np.frombuffer(stringVideoData, np.uint8)#将获取到的字符流数据转换成1维数组
            frame=cv2.imdecode(videodata,cv2.IMREAD_COLOR)#将数组解码成图像
            show = cv2.flip(cv2.cvtColor(frame, cv2.COLOR_BGR2RGB),1)
            showImage = QImage(show.data, show.shape[1], show.shape[0], QImage.Format_RGB888)
            self.videoLabel.setPixmap(QPixmap.fromImage(showImage))# 将图像显示在之前创建的Label控件中
        self.timer_receive_video.start(10)
    def receive_text(self):
        # print('re')
        if self.is_connect:
            self.Btcp.setblocking(False)
            try:
                stringData = self.recvData(self.Btcp, key=self.key,type='tcp')
            except:
                return
                # time.sleep(10)
                # continue
            try:
                text = stringData.decode()
            except:#对方已经断开连接
                self.is_connect = False
                return
            print('s:::'+text)
            if text!='':
                
                self.historytext+=(text+'\n')
            self.inputframe.setText("")
            self.outputframe.setText(self.historytext)
            cursor = self.outputframe.textCursor()
            pos = len(self.outputframe.toPlainText())
            cursor.setPosition(pos-1)
            self.outputframe.ensureCursorVisible()
            self.outputframe.setTextCursor(cursor)
        self.timer_receive_text.start(10)
    def show_pic(self):
        # print('show_pic')
        if self.is_connect==False:
            success, frame=self.cap.read()
            if success:
                show = cv2.flip(cv2.cvtColor(frame, cv2.COLOR_BGR2RGB),1)

                showImage = QImage(show.data, show.shape[1], show.shape[0], QImage.Format_RGB888)
                self.videoLabel.setPixmap(QPixmap.fromImage(showImage))# 将摄像头显示在之前创建的Label控件中
        self.timer_camera.start(10)
        
    def listen(self):
        #print('listen')
        if(not self.is_connect):
            try:
                self.Btcp,self.comefriendaddr = self.listensocket.accept()
            except:
                return
            
            #接收票据
            clienttcp = self.Btcp#换名方便使用
            clienttcp.setblocking(True)
            ticket = self.recvData(clienttcp)
            #提取A的公钥
            ticket = self.decrypt(ticket, self.privkey)#bytes
            (Apubkey,self.comfriendname) = eval(ticket.decode())
            Apubkey = rsa.PublicKey.load_pkcs1(Apubkey)
            data = Random.new().read(16)#随机验证码
            cipher = self.encrypt(data, Apubkey)
            self.sendData(clienttcp, cipher)
            Rdata = self.recvData(clienttcp)
            Rdata= self.decrypt(Rdata, self.privkey)#bytes
            plain,self.friendname = eval(Rdata.decode())
            if plain == data :
                button = QMessageBox.question(self,"连接请求","‘"+self.friendname+"’想要和您建立通信，是否同意？",
                                      QMessageBox.Ok|QMessageBox.Cancel,QMessageBox.Ok)
                if button == QMessageBox.Ok:
                    pass
                elif button == QMessageBox.Cancel:
                    return
                else:
                    return
                print("验证通过，发送AES密钥")
                self.is_connect = True
                self.key = Random.new().read(16)#128bit对称密钥
                key_ciphered = self.encrypt(self.key,Apubkey)
                self.sendData(clienttcp, key_ciphered)
                
                self.Bip = self.comefriendaddr[0]
                self.videoudp = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
                self.videoudp.connect((self.Bip,9999))
                self.sendvoiceudp = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
                self.sendvoiceudp.connect((self.Bip,9998))
                self.receiveVideoUdp = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
                self.receiveVideoUdp.bind(('0.0.0.0', 9999))
                self.receiveVideoUdp.setblocking(False)
                self.receivevoiceudp = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
                self.receivevoiceudp.bind(('0.0.0.0', 9998))
                self.receivevoiceudp.setblocking(False)

                self.timer_receive_voice.start(1)
                self.timer_send_voice.start(1)
                self.timer_receive_video.start(10)
                self.timer_send_video.start(10)
                self.timer_receive_text.start(10)

                self.is_connect = True
                self.Bip = self.comefriendaddr[0]
                self.Btcp = clienttcp
                self.Btcp.setblocking(False)
            else:
                print("验证失败")
            # clienttcp.close()
        self.timer_listenservertcp.start(5)
    
    def verify(self):
        print('verify')
        self.servertcp.close()
        self.servertcp = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    #建立连接
        self.servertcp.connect(('172.20.18.73',8080))
        #接收KDC公钥
        self.KDCpubkey = self.recvData(self.servertcp)
        self.KDCpubkey = rsa.PublicKey(*eval(self.KDCpubkey.decode()))
        #发送用户名密码
        verify_code = Random.new().read(16)#128bit随机验证码
        data = str((self.username,self.password,verify_code,None)).encode()
        data = self.encrypt(data,self.KDCpubkey)
        self.sendData(self.servertcp,data)
        #接收服务器回应
        reply = self.recvData(self.servertcp)
        #验证这是KDC签过名的verify_code
        try:
            rsa.verify(verify_code, reply, self.KDCpubkey)
            return True
        except:
            return False
    def acceptMessages(self,m):
        self.servertcp= m['serversocket']
        self.KDCpubkey = m['KDCpubkey']
        self.username = m['username']
        self.password = m['password']

    def fun(self):#send_text
        print('fun')
        # self.text_show2 = QtGui.QTextEdit()
        # cursor = self.text_show2.textCursor()
        # pos = len(self.text_show2.toPlainText())
        # cursor.setPosition(pos-1)
        # self.text_show2.ensureCursorVisible()
        # self.text_show2.setTextCursor(cursor)
        text = self.inputframe.text()
        if text!='':
            text = self.username+":\t"+text
            # print(self.inputframe.text())
            if self.is_connect:
                self.sendData(self.Btcp,text.encode(),self.key)

            self.historytext+=(text+'\n')
        self.inputframe.setText("")
        self.outputframe.setText(self.historytext)
        cursor = self.outputframe.textCursor()
        pos = len(self.outputframe.toPlainText())
        cursor.setPosition(pos-1)
        self.outputframe.ensureCursorVisible()
        self.outputframe.setTextCursor(cursor)
    
    def registController(self, controller):
        self.controller = controller
   
    
if __name__=='__main__':
    app = QtWidgets.QApplication(sys.argv)
    # MainWindow = QtWidgets.QMainWindow()
    # ui = Ui_MainWindow()
    # ui.setupUi(MainWindow)
    MainWindow = Window_MainWindow()
    MainWindow.show()
    sys.exit(app.exec_())